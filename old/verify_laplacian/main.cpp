
double gauss_2d_lap_poly_0 [] = { 1.00e+00 };
double gauss_2d_lap_poly_1 [] = { -4.00e+00, 0.0, 4.00e+00 };
double gauss_2d_lap_poly_2 [] = { 3.20e+01, 0.0, -6.40e+01, 0.0, 1.60e+01 };
double gauss_2d_lap_poly_3 [] = { -3.840e+02, 0.0, 1.15200e+03, 0.0, -5.760e+02, 0.0, 6.40e+01 };
double gauss_2d_lap_poly_4 [] = { 6.14400e+03, 0.0, -2.45760e+04, 0.0, 1.84320e+04, 0.0, -4.09600e+03, 0.0, 2.560e+02 };
double gauss_2d_lap_poly_5 [] = { -1.22880e+05, 0.0, 6.14400e+05, 0.0, -6.14400e+05, 0.0, 2.04800e+05, 0.0, -2.560e+04, 0.0, 1.02400e+03 };
double gauss_2d_lap_poly_6 [] = { 2.949120e+06, 0.0, -1.76947200e+07, 0.0, 2.211840e+07, 0.0, -9.83040e+06, 0.0, 1.84320e+06, 0.0, -1.474560e+05, 0.0, 4.09600e+03 };
double gauss_2d_lap_poly_7 [] = { -8.25753600e+07, 0.0, 5.78027520e+08, 0.0, -8.67041280e+08, 0.0, 4.81689600e+08, 0.0, -1.20422400e+08, 0.0, 1.44506880e+07, 0.0, -8.028160e+05, 0.0, 1.63840e+04 };
double gauss_2d_lap_poly_8 [] = { 2.642411520e+09, 0.0, -2.11392921600e+10, 0.0, 3.69937612800e+10, 0.0, -2.46625075200e+10, 0.0, 7.70703360e+09, 0.0, -1.23312537600e+09, 0.0, 1.027604480e+08, 0.0, -4.19430400e+06, 0.0, 6.55360e+04 };
double gauss_2d_lap_poly_9 [] = { -9.51268147200e+10, 0.0, 8.56141332480e+11, 0.0, -1.712282664960e+12, 0.0, 1.331775406080e+12, 0.0, -4.99415777280e+11, 0.0, 9.98831554560e+10, 0.0, -1.10981283840e+10, 0.0, 6.794772480e+08, 0.0, -2.12336640e+07, 0.0, 2.621440e+05 };
double gauss_2d_lap_poly_10 [] = { 3.80507258880e+12, 0.0, -3.80507258880e+13, 0.0, 8.56141332480e+13, 0.0, -7.61014517760e+13, 0.0, 3.32943851520e+13, 0.0, -7.990652436480e+12, 0.0, 1.10981283840e+12, 0.0, -9.059696640e+10, 0.0, 4.24673280e+09, 0.0, -1.04857600e+08, 0.0, 1.04857600e+06 };
double gauss_2d_lap_poly_11 [] = { -1.67423193907200e+14, 0.0, 1.84165513297920e+15, 0.0, -4.60413783244800e+15, 0.0, 4.60413783244800e+15, 0.0, -2.30206891622400e+15, 0.0, 6.44579296542720e+14, 0.0, -1.07429882757120e+14, 0.0, 1.096223293440e+13, 0.0, -6.85139558400e+11, 0.0, 2.537553920e+10, 0.0, -5.075107820e+08, 0.0, 4.19430400e+06 };
double gauss_2d_lap_poly_12 [] = { 8.03631330754560e+15, 0.0, -9.643575969054720e+16, 0.0, 2.65198339149004800e+17, 0.0, -2.946648212766720e+17, 0.0, 1.657489619681280e+17, 0.0, -5.30396678298009600e+16, 0.0, 1.03132687446835200e+16, 0.0, -1.262849234042880e+15, 0.0, 9.866009640960e+13, 0.0, -4.87210352640e+12, 0.0, 1.461631057940e+11, 0.0, -2.41591910e+09, 0.0, 1.67772160e+07 };
double gauss_2d_lap_poly_13 [] = { -4.17888291992371200e+17, 0.0, 5.43254779590082560e+18, 0.0, -1.629764338770247680e+19, 0.0, 1.991934191830302720e+19, 0.0, -1.24495886989393920e+19, 0.0, 4.481851931618181120e+18, 0.0, -9.95967095915151360e+17, 0.0, 1.42281013702164480e+17, 0.0, -1.33388450345779200e+16, 0.0, 8.23385495961600e+14, 0.0, -3.29354198384620e+13, 0.0, 8.165806571560e+11, 0.0, -1.13413980100e+10, 0.0, 6.71088640e+07 };
double gauss_2d_lap_poly_14 [] = { 2.340174435157278720e+19, 0.0, -3.276244209220190208e+20, 0.0, 1.064779367996561818e+21, 0.0, -1.419705823995415757e+21, 0.0, 9.760477539968483328e+20, 0.0, -3.904191015987393331e+20, 0.0, 9.760477539968483328e+19, 0.0, -1.593547353464242176e+19, 0.0, 1.742942417851514880e+18, 0.0, -1.29106845766778880e+17, 0.0, 6.45534228833894600e+15, 0.0, -2.133997450690520e+14, 0.0, 4.44582802227800e+12, 0.0, -5.26133493680e+10, 0.0, 2.684354560e+08 };
double gauss_2d_lap_poly_15 [] = { -1.404104661094367232e+21, 0.0, 2.106156991641550848e+22, 0.0, -7.371549470745427968e+22, 0.0, 1.064779367996561818e+23, 0.0, -7.985845259974213632e+22, 0.0, 3.513771914388653998e+22, 0.0, -9.760477539968483328e+21, 0.0, 1.792740772647272448e+21, 0.0, -2.240925965809090560e+20, 0.0, 1.93660268650168320e+19, 0.0, -1.161961611901009920e+18, 0.0, 4.801494264053760e+16, 0.0, -1.33374840668159400e+15, 0.0, 2.36760072192080e+13, 0.0, -2.41591910400e+11, 0.0, 1.07374182400e+09 };

int gauss_2d_lap_poly_degrees [] = { 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30 };

double * gauss_2d_lap_poly [] = { &(gauss_2d_lap_poly_0[0]), &(gauss_2d_lap_poly_1[0]), &(gauss_2d_lap_poly_2[0]), &(gauss_2d_lap_poly_3[0]), &(gauss_2d_lap_poly_4[0]), &(gauss_2d_lap_poly_5[0]), &(gauss_2d_lap_poly_6[0]), &(gauss_2d_lap_poly_7[0]), &(gauss_2d_lap_poly_8[0]), &(gauss_2d_lap_poly_9[0]), &(gauss_2d_lap_poly_10[0]), &(gauss_2d_lap_poly_11[0]), &(gauss_2d_lap_poly_12[0]), &(gauss_2d_lap_poly_13[0]), &(gauss_2d_lap_poly_14[0]), &(gauss_2d_lap_poly_15[0]) };


//#define FFTW_PLAN_MODE FFTW_PATIENT

#define N_FFT_THREADS  1


#include <mathlib/math/std_math.h>
#include <mathlib/math/grids/grid2D.h>
#include <mathlib/math/transforms/fft.h>
#include <mathlib/math/laplacian/laplacian.h>
#include <mathlib/math/laplacian/laplacian_FD.h>
#include <mathlib/math/laplacian/laplacian_hdaf.h>

#include <mathlib/math/grids/extra/plots.cpp>

#include "common.h"

#include <mathlib/non-lib_things.h>

#include <mathlib/link.cpp>



ml_color cmap(double x)
{
	x *= 10;
	float s = atan(x)/pi+0.5;
	return ml_color(s,s,s);
}

ml_poly<double > * GLP = construct_ml_poly_array<double, double > ( gauss_2d_lap_poly, gauss_2d_lap_poly_degrees, 15 );



class gauss : public functor2<double,double >
{
public:
    int n;
    gauss(int n):n(n) {};
    
public:
	double operator() (double const & x1, double const & x2) const 
	{
        double s = sqrt(x1*x1+x2*x2);
        return GLP[n](s)*exp(-x1*x1)*exp(-x2*x2);
	}
};





int main()
{
    std_setup();
    
    int N = 12;
    double X0 = 10;
    int n1 = 256;
    int n2 = n1;
    
    rgrid2D grid( n1, -X0, X0,  n2, -X0, X0 );
    
    rgrid2D * AN = new rgrid2D [N+1];
    for (int k=0; k<=N; k++ )
        AN[k] = grid;
        
    rgrid2D * NU = new rgrid2D [N+1];
    for (int k=0; k<=N; k++ )
        NU[k] = grid;
    
//    laplacian_2d_fd Del2;
//    Del2.init( grid.n1, grid.n2, grid.b1-grid.a1, grid.b2-grid.a2, 24, 24 );
    
    double gamma = 0.4;
    int m = 12;
    
    laplacian_2d_hdaf Del2;
    Del2.init( grid.n1, grid.n2, grid.b1-grid.a1, grid.b2-grid.a2, m, m,  gamma, gamma );
    
    for (int k=0; k<=N; k++ )
        AN[k] = gauss(k);
    
    NU[0] = AN[0];
    
    for (int k=1; k<=N; k++ )
        Del2.execute( NU[k-1].array, NU[k].array );
    
    double * x = ml_alloc<double> (N);
    double * y = ml_alloc<double> (N);
    
    for (int k=1; k<=N; k++ )
    {
        y[k-1] = log10(l2_error( AN[k].array, NU[k].array, n1, n2 ));
        x[k-1] = k;
        
        if (k >1 ) cout << k << "\t" << y[k-1] << "\t" << y[k-1]-y[k-2] << endl;
        else cout << k << "\t" << y[k-1] << endl;
        
        sprintf(fname, "/workspace/output/temp/numeric_%02d.png", k );
        plotGrid2D_1( NU[k], fname,cmap);
        
        sprintf(fname, "/workspace/output/temp/analytic_%02d.png", k );
        plotGrid2D_1( AN[k], fname,cmap);
    }
    
    double slope, wefqewf;
    ml_slope( x, y, N, slope, wefqewf );
    
    cout << slope << endl;
}


